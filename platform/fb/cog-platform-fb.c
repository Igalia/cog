/*
 * cog-platform-fb.c - PROOF OF CONCEPT
 * Copyright (C) 2021 House Gordon Software Company LTD <kernel@housegordon.com>
 * Copyright (C) 2021 Igalia S.L
 *
 * Distributed under terms of the MIT license.
 */
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <linux/fb.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <string.h>


#include <wpe/webkit.h>
#include <wpe/fdo.h>
#include <wpe/unstable/fdo-shm.h>

#include <wayland-server.h>

#include "../../core/cog.h"

#define DEFAULT_FPS 10
#define MAX_FPS 100 // quite arbitrary, but reasonable?
#define DEFAULT_FB_DEV_NUM 0  // /dev/fb0

static int s_fb_dev_num = DEFAULT_FB_DEV_NUM ;
static int s_fps = DEFAULT_FPS ;


struct Cog_FB_Connection {
	struct {
		char *devname;
		int fd; // file descriptor
		struct fb_var_screeninfo vinfo;
		struct fb_fix_screeninfo finfo;
		long page_aligned_size;
		char *fbp; // mmap'd pointer
		gboolean simple_memmove ;
	} fb;

	struct {
		struct wpe_view_backend_exportable_fdo *exportable;
		struct wpe_view_backend *backend;
		gboolean frame_complete;
	} wpe;

	struct {
		guint tick_source;
		GPollFD  poll_fd;
	} glib;
};

static struct Cog_FB_Connection s_fb;


/*
   Given a wayland shm-buffer (representing a rendered screen,
   generated by WPE) - copy its content (e.g. raw RGBX bytes)
   to the framebuffer.
   */
static void wpe_copy_shm_buffer (struct wl_shm_buffer *shm_buffer)
{
	int32_t width = wl_shm_buffer_get_width (shm_buffer);
	int32_t height = wl_shm_buffer_get_height (shm_buffer);
	int32_t stride = wl_shm_buffer_get_stride (shm_buffer);
	uint32_t format = wl_shm_buffer_get_format (shm_buffer);

	//uint32_t bo_stride = 0;
	if (format != WL_SHM_FORMAT_ARGB8888 && format != WL_SHM_FORMAT_XRGB8888) {
		g_warning("wpe_copy_shm_buffer: format is not recognized - skipping");
		return;
	}

	//The size of the image sent from WPE does not match the size of
	//the framebuffer. Can commonly happen during a resize.
	//Skip updating the image.
	if (width != s_fb.fb.vinfo.xres || height != s_fb.fb.vinfo.yres)
		return;

	g_info("Got new buffer from WPE, size = %d x %d", width, height);

	wl_shm_buffer_begin_access (shm_buffer);

	uint8_t *src = wl_shm_buffer_get_data (shm_buffer);

	if (s_fb.fb.simple_memmove) {
		memmove(s_fb.fb.fbp, src, stride*height);
	} else {
		char *dst = s_fb.fb.fbp;
		for (int y=0;y<height;++y) {
			memmove (dst, src, width * 4);
			src += stride;
			dst += s_fb.fb.finfo.line_length;
		}
	}

	wl_shm_buffer_end_access (shm_buffer);

}

/*
   Parse and validate a numeric value from a given string.
   The value must be a valid number, non-negative,
   non-zero (unless 'allow_zero' is true),
   must fit in an 'int', and not have any trailing characters.

   Returns TRUE if all the above conditions are met,
   with the numeric value stored in 'numval'.
   */
static gboolean parse_option_numeric_value (const char* subopt_name,
		const char* value,
		gboolean allow_zero,
		int* /*output*/ numval)
{
	if (value == NULL) {
		g_error("missing numeric value for sub-option '%s'", subopt_name);
		return FALSE;
	}

	char *endptr = NULL ;
	errno = 0 ;
	gint64 tmp = g_ascii_strtoll(value, &endptr, 10);
	if ( (tmp == G_MAXUINT64) || (tmp == G_MININT64) ||
			(tmp == 0 && errno == EINVAL) ||
			(endptr && *endptr != '\0')) {
		g_error("invalid value '%s' for sub-option '%s'", value, subopt_name);
		return FALSE;
	}

	// Zero and negative numbers are rejected (no option accepts them so far).
	if ( (tmp < 0) || ( tmp == 0 && !allow_zero) ) {
		g_error("invalid value '%ld' for sub-option '%s' - must be %s0",
				(long int)tmp, subopt_name, allow_zero?">=":">");
		return FALSE;
	}

	// Too-big values are rejected, so valid values will fit in an 'int')
	if (tmp > G_MAXINT) {
		g_error("invalid value '%ld' for sub-option '%s' - value too large", (long int)tmp, subopt_name);
		return FALSE;
	}

	g_assert_nonnull (numval);
	*numval = (int)tmp ;

	return TRUE;
}


/*
   Parse the option string passed to this platform module.
   The format should match the 'getsubopt(3)' function
   (think the 'mount -o [OPTIONS]' string).
   */
static gboolean parse_option_string(const char* params)
{
	enum {
		FPS_OPT = 0,
		FB_NUM_OPT
	};
	char *const token[] = {
		[FPS_OPT]   = "fps",
		[FB_NUM_OPT] = "fb",
		NULL
	};
	char *orig, *subopts;
	char *value;
	int opt;
	int numval ;

	if (!params || *params=='\0')
		return TRUE;

	orig = subopts = g_strdup(params);

	while (*subopts != '\0') {
		opt = getsubopt(&subopts, token, &value);

		// These options require a numeric value
		if ( (opt == FPS_OPT) || (opt == FB_NUM_OPT) ) {
			const gboolean allow_zero = (opt == FB_NUM_OPT);
			if (!parse_option_numeric_value (token[opt], value,
						allow_zero, &numval))
				goto fail;
		}

		switch (opt)
		{
			case FPS_OPT:
				if (numval > MAX_FPS) { // arbitrary ...
					g_error("invalid FPS value '%d' - must be less than %d", numval, MAX_FPS);
					goto fail;
				}
				s_fps = numval;
				break ;

			case FB_NUM_OPT:
				s_fb_dev_num = numval;
				break;

			default:
				g_error("unknown sub-option found in '%s'", params);
				goto fail;
		}
	}

	g_free (orig);
	return TRUE;

fail:
	g_free (orig);
	return FALSE;
}


static void fb_print_information()
{
	const struct fb_fix_screeninfo finfo = s_fb.fb.finfo;
	const struct fb_var_screeninfo vinfo = s_fb.fb.vinfo;

	printf("device = %s\n", s_fb.fb.devname);
	printf("file-desc = %d\n", s_fb.fb.fd);

	printf("\nFIXED INFORMATION:\n");

	printf("id = %s\n", finfo.id);
	printf("smem_start = 0x%lx\n", finfo.smem_start);
	printf("smem_legnth = %u\n", finfo.smem_len);
	printf("type = %d\n", finfo.type);
	printf("visual = %d\n", finfo.visual); //see: https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/fb.h#L16
	printf("x/y panstep (wrap)= %u x %u (%u)\n", finfo.xpanstep, finfo.ypanstep, finfo.ywrapstep);
	printf("line length = %u\n", finfo.line_length);
	printf("capabilities = %x\n", finfo.capabilities);

	printf("screen-size (PAGE_SIZE aligned): %ld\n", s_fb.fb.page_aligned_size);

	if (finfo.type != FB_TYPE_PACKED_PIXELS) {
		printf("NOT PACKED PIXELS!\n");
	}
	if (finfo.visual != FB_VISUAL_TRUECOLOR) {
		printf("NOT TRUECOLOR\n");
	}


	printf("\nVARIABLE INFORMATION:\n");
	printf("visibile res: %u x %u\n", vinfo.xres, vinfo.yres);
	printf("virtual  res: %u x %u\n", vinfo.xres_virtual, vinfo.yres_virtual);
	printf("vis-to-virt offset: %u x %u\n", vinfo.xoffset, vinfo.yoffset);
	printf("bits-per-pixel: %d\n", vinfo.bits_per_pixel);
	printf("color mode:");
	if (vinfo.grayscale==0)
		printf("color\n");
	else if (vinfo.grayscale==1)
		printf("grayscale\n");
	else
		printf("FOURCC: 0x%08x\n",
				vinfo.grayscale);

	printf("Pixel format: %sstandard\n", vinfo.nonstd?"NON-":"");

	printf("  red  :  %d bits, offset %d,  msb on %s\n", vinfo.red.length, vinfo.red.offset, vinfo.red.msb_right?"right":"left");
	printf("  green:  %d bits, offset %d,  msb on %s\n", vinfo.green.length, vinfo.green.offset, vinfo.green.msb_right?"right":"left");
	printf("  blue :  %d bits, offset %d,  msb on %s\n", vinfo.blue.length, vinfo.blue.offset, vinfo.blue.msb_right?"right":"left");
	printf("  alpha:  %d bits, offset %d,  msb on %s\n", vinfo.transp.length, vinfo.transp.offset, vinfo.transp.msb_right?"right":"left");

	long screensize_bbp = vinfo.xres_virtual * vinfo.yres_virtual * vinfo.bits_per_pixel / 8;
	printf("screen-size by bbp: %ld\n",  screensize_bbp);
}

//From: https://linux-arm-kernel.infradead.narkive.com/XL0ylAHW/turn-off-framebuffer-cursor
static void fbcon_cursor (int show)
{
	int fd = open("/dev/tty0", O_RDWR);
	if(0 < fd) {
		write(fd, "\033[?25", 5);
		write(fd, show ? "h" : "l", 1);
	}
	close(fd);
}

/*
Checks if the currently set framebuffer mode is supported.
NOTE:
None of these limitations are set in stone.
Current implementation keeps it simple by requiring the same pixel format
as the wayland SHM buffers received from WPE.

It is possible to write efficient pixel conversion routines
to support additional framebuffer modes
*/
static gboolean fb_useable_mode()
{
	const struct fb_fix_screeninfo finfo = s_fb.fb.finfo;
	const struct fb_var_screeninfo vinfo = s_fb.fb.vinfo;

	if (finfo.type != FB_TYPE_PACKED_PIXELS) {
		g_error("Unsupported Framebuffer mode: not packed-pixels");
		return FALSE;
	}
	if (finfo.visual != FB_VISUAL_TRUECOLOR) {
		g_error("Unsupported Framebuffer mode: not True-Color");
		return FALSE;
	}

	if (vinfo.bits_per_pixel != 32) {
		g_error("Unsupported Framebuffer mode: not 32 bits-per-pixel");
		return FALSE;
	}
	if (vinfo.grayscale != 0) {
		g_error("Unsupported Framebuffer mode: not using simple color mode");
		return FALSE;
	}
	if ( (vinfo.xres != vinfo.xres_virtual) || (vinfo.yres != vinfo.yres_virtual)) {
		g_error("Unsupported Framebuffer mode: visual resolution != virtual resolution");
		return FALSE;
	}

	if ( (vinfo.red.length != 8) || (vinfo.blue.length != 8) || (vinfo.green.length != 8) ) {
		g_error("Unsupported Framebuffer mode: red/green/blue must be 8 bits");
		return FALSE;
	}

	if ( (vinfo.red.offset != 16) || (vinfo.green.offset  != 8) || (vinfo.blue.offset != 0) ) {
		g_error("Unsupported Framebuffer mode: packed pixel order must be RGB");
		return FALSE;
	}

	// Just a warning - we can handle that, but it'll be slower.
	if ( (vinfo.xres_virtual * vinfo.bits_per_pixel / 8) != finfo.line_length) {
		g_warning("Framebuffer line length (%d) not equal to virtual-width*bpp/8 (%d) - screen updating will be slower (and cause higher CPU usage)",
			finfo.line_length, vinfo.xres_virtual*vinfo.bits_per_pixel/8);
		s_fb.fb.simple_memmove = false;
	} else {
		s_fb.fb.simple_memmove = true;
	}

	return TRUE;
}


static gboolean fb_init()
{
	s_fb.fb.devname = g_strdup_printf("/dev/fb%d",s_fb_dev_num);

	// Open the file for reading and writing
	s_fb.fb.fd = open(s_fb.fb.devname, O_RDWR);
	if (s_fb.fb.fd == -1) {
		g_error("failed to open framebuffer device '%s': %m", s_fb.fb.devname);
		return FALSE;
	}

	// Get fixed screen information
	if (ioctl(s_fb.fb.fd, FBIOGET_FSCREENINFO, &s_fb.fb.finfo) == -1) {
		g_error("failed to read fixed screen info (FBIOGET_FSCREENINFO) for '%s': %m", s_fb.fb.devname);
		return FALSE;
	}

	// Get variable screen information
	if (ioctl(s_fb.fb.fd, FBIOGET_VSCREENINFO, &s_fb.fb.vinfo) == -1) {
		g_error("failed to read variable screen info (FBIOGET_VSCREENINFO) for '%s': %m", s_fb.fb.devname);
		return FALSE;
	}

	long page_size = getpagesize();
	long ppc_fx = (((long)s_fb.fb.finfo.smem_start) - ((long) s_fb.fb.finfo.smem_start & ~(page_size-1)));
	s_fb.fb.page_aligned_size = s_fb.fb.finfo.smem_len + ppc_fx;


	fb_print_information();

	if (!fb_useable_mode()) {
		return FALSE;
	}

	// Map the device to memory
	s_fb.fb.fbp = (char *)mmap(0, s_fb.fb.page_aligned_size,
			PROT_READ | PROT_WRITE, MAP_SHARED,
			s_fb.fb.fd, 0);
	if ((int)s_fb.fb.fbp == -1) {
		g_error("failed to map framebuffer device (%s) fd(%d) size(%ld)", s_fb.fb.devname, s_fb.fb.fd, s_fb.fb.page_aligned_size);
		return FALSE;
	}

	fbcon_cursor(0);

	return TRUE;
}

static void fb_clear()
{
	fbcon_cursor(1);

	if ( (s_fb.fb.fbp != 0) && ((int)s_fb.fb.fbp != -1)) {
		if (! munmap(s_fb.fb.fbp, s_fb.fb.page_aligned_size) ) {
			g_warning("failed to release(unmap) framebuffer device '%s' (ptr: %p): %m", s_fb.fb.devname, s_fb.fb.fbp);
		}
		s_fb.fb.fbp = NULL ;
	}

	if (s_fb.fb.fd) {
		if (!close(s_fb.fb.fd))
			g_warning("failed to close framebuffer device '%s' (fd %d): %m", s_fb.fb.devname, s_fb.fb.fd);
		s_fb.fb.fd = 0;
	}

	if (s_fb.fb.devname) {
		g_clear_pointer (&s_fb.fb.devname, g_free);
	}
}

/*
   This is the callback function used the WPE/FDO to notify the
   application that new rendered HTML content is available.

   This can be called rarely (on a simple static websites)
   or frequently (on very active website with lots of animations).

   To throttle the display speed, this function DOES NOT
   sends the "frame complete" ack back to WPE/FDO.
   instead, it sets the "frame_complete" flag to TRUE,
   and the "tick_source" will ACK the frame based on the FPS settings.
   */
static void on_export_shm_buffer(void* data, struct wpe_fdo_shm_exported_buffer* exported_buffer)
{
	struct wl_shm_buffer *exported_shm_buffer = wpe_fdo_shm_exported_buffer_get_shm_buffer (exported_buffer);

	wpe_copy_shm_buffer(exported_shm_buffer);

	wpe_view_backend_exportable_fdo_dispatch_release_shm_exported_buffer(s_fb.wpe.exportable, exported_buffer);

	s_fb.wpe.frame_complete = TRUE ;
}


/*
   This timer function is called by the glib framework.
   It ACKs a received 'shm_buffer' frame.
See: on_export_shm_buffer() for details.
*/
static gboolean glib_tick_callback(gpointer data)
{
	if (s_fb.wpe.frame_complete) {
		s_fb.wpe.frame_complete = FALSE ;
		wpe_view_backend_exportable_fdo_dispatch_frame_complete(s_fb.wpe.exportable);
	}
	return G_SOURCE_CONTINUE;
}


static gboolean glib_init (void)
{
	//
	// Attach a timed source to the glib framework.
	//
	s_fb.glib.tick_source = g_timeout_add(1000/s_fps,
			G_SOURCE_FUNC(glib_tick_callback), NULL);

	return TRUE;
}


static void glib_clear (void)
{
	g_source_remove(s_fb.glib.tick_source);
}




gboolean cog_platform_plugin_setup (CogPlatform *platform,
		CogShell    *shell G_GNUC_UNUSED,
		const char  *params,
		GError     **error)
{
	g_assert (platform);
	g_return_val_if_fail (COG_IS_SHELL (shell), FALSE);

	if (!parse_option_string (params)) {
		g_set_error_literal (error,
				COG_PLATFORM_WPE_ERROR,
				COG_PLATFORM_WPE_ERROR_INIT,
				"Failed to parse FB options");
		return FALSE;
	}

	if (!wpe_loader_init ("libWPEBackend-fdo-1.0.so")) {
		g_set_error_literal (error,
				COG_PLATFORM_WPE_ERROR,
				COG_PLATFORM_WPE_ERROR_INIT,
				"Failed to set backend library name");
		return FALSE;
	}

	if (!fb_init ()) {
		g_set_error_literal (error,
				COG_PLATFORM_WPE_ERROR,
				COG_PLATFORM_WPE_ERROR_INIT,
				"Failed to initialize FrameBuffer");
		return FALSE;
	}

	if (!glib_init ()) {
		g_set_error_literal (error,
				COG_PLATFORM_WPE_ERROR,
				COG_PLATFORM_WPE_ERROR_INIT,
				"Failed to initialize GLib");
		return FALSE;
	}

	return TRUE;
}

void cog_platform_plugin_teardown (CogPlatform *platform)
{
	g_assert (platform);

	fb_clear ();
	glib_clear ();
}

WebKitWebViewBackend* cog_platform_plugin_get_view_backend (CogPlatform   *platform,
		WebKitWebView *related_view,
		GError       **error)
{
	g_assert_nonnull(platform);

	wpe_fdo_initialize_shm();

	static const struct wpe_view_backend_exportable_fdo_client client = {
		.export_shm_buffer = on_export_shm_buffer,
	};

	s_fb.wpe.exportable = wpe_view_backend_exportable_fdo_create(&client, &s_fb,
			s_fb.fb.vinfo.xres,
			s_fb.fb.vinfo.yres);

	/* init WPE view backend */
	s_fb.wpe.backend =
		wpe_view_backend_exportable_fdo_get_view_backend (s_fb.wpe.exportable);
	g_assert (s_fb.wpe.backend);

	WebKitWebViewBackend *wk_view_backend =
		webkit_web_view_backend_new (s_fb.wpe.backend,
				(GDestroyNotify) wpe_view_backend_exportable_fdo_destroy,
				s_fb.wpe.exportable);
	g_assert (wk_view_backend);
	return wk_view_backend;
}
